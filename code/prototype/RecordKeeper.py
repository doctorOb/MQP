import os
import sys
import json
import time


class RecordKeeper(object):
	"""
	This class manages a persistent dictionary of statistics generated by entities.
	Requires an 'entity name', which will act as the default file name. Apart from that, 
	this is essentially a simple persistent dictionary.
	"""
	def __init__(self,ename, new=False):

		self.fname = ename
		self.ename = ename #the name of the entity being logged. 
		self.book = {}
		
		if not new and os.path.exists('{}.json'.format(ename)):
			self.load() #try to load in an old book
		else:
			self.save(); #create the file


	def __getitem__(self,key):
		"""get an item in the book with dict syntax"""
		try:
			return self.book[key]
		except KeyError:
			return None

	def __setitem__(self,key,value):
		"""set an item in the book with dict syntax"""
		self.book[key] = value

	def save(self,fn=None):
		"""serialize the records book into a json file"""
		fname = fn if fn else self.fname
		with open("{}.json".format(fname),'w') as f:
			f.write(json.dumps(self.book))

	def load(self,fn=None):
		"""deserialize the records book from a json file.
		Converts unicode characters into python strings"""
		fname = fn if fn else self.fname
		with open("{}.json".format(fname),'r') as f:
			tmp_book = json.load(f)

		type_unicode = type(u'a')
		for key in tmp_book:
			val = tmp_book[key]
			if type(key) == type_unicode:
				key = str(key)
			if type(val) == type_unicode:
				val = str(val)
			self.book[key] = val





class SessionRecord(RecordKeeper):
	"""
	an extension of the record keeper class, with extra data included for connection informationsel.
	The conformed format is along the lines of ...

		target_uri: [url]
		date: [timestamp]
		request_size: [int]
		timeout: [timestamp]
	"""
	STAMP = "%X %x %z"

	def __init__(self,ename,fname=None):
		super(self.__class__,self).__init__(ename)
		if 'session_records' not in self.book:
			self.book['session_records'] = []
		self._sessions = self.book['session_records']
		self.book['timeouts'] = 0 if 'timeouts' not in self.book else self.book['timeouts']
		self.book['sessions'] = 0 if 'sessions' not in self.book else self.book['timeouts']

	def sessions(self):
		"""generator that returns all the session dicts tied to this record"""
		for session in self._sessions:
			yield session

	def _current(self):
		try:
			return self._sessions[len(self._sessions) - 1]
		except:
			return None

	def new(self,target="",req_size=0):
		self._sessions.append({
			'target_uri' : target,
			'request_size' : req_size,
			'date' : time.strftime(self.STAMP)
		})
		self.book['sessions'] += 1

	def timeout(self):
		self._current()['timeout'] = time.strftime(self.STAMP)
		self.book['timeouts'] += 1


if __name__ == '__main__':
	#tests
	r = SessionRecord('127.0.0.1')
	r.new(target='url/static',req_size=20000)
	r.timeout()
	r.save()
	for session in r.sessions():
		print session['date']
		print session['target_uri']





